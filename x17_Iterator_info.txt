
    Паттерн 17: ИТЕРАТОР:
-------------------------
    --  Описание паттерна:
    ----------------------
    Предоставляет способ последовательного доступа
    к элементам множества,
    независимо от внутреннего устройства
    такого множества.

    Не будем рассматривать как работают
    итераторы стандартные по коллекциям (конечные итераторы)
    тут ситуация может быть другой.

    Множество может быть и не множеством,
    а чем то бесконечным,
    или конечным - но с желанием идти по кругу.

    В любом случае итератор это
    внешний по сравнению к итерируемому классу класс
    который перебирает элементы итерируемого класса.

    Итератор знает какой класс он перебирает,
    а вот перебираемый класс может даже и не знать об итераторе.
    (в коллекциях итераторы порождаются фабриками
    которые находятся внутри самих объектов, но как будет видно
    это просто усложнение паттерна)

    Итератор может быть применим и к математическим ситуациям
    связанным с вычислениями
    например получать вертексы по степени удаления от точки
    в 3д пространстве <- технически тут даже массива данных то нету.
    однако перечисление вполне себе закономерно.
    ----
    тут еще нужно понимать что
    главная суть итератора - это не просто создать итерируемый объект
    или дать возможность чему то быть итерируемым
    а передавать данные с элемента на элемент
    и достигнуть следующей цепочки:
    (iterator) -> (data) -> (consumer) -> (next)   <-- данные ВЫТЯГИВАЮТСЯ (pull) consumer-ом
    то есть данные передаются всетаки в "потребителя"
    for(var el : elements){
        <- технически это consumer (иначе паттерн бессмысленен)
    }
    и этим
    паттерн очень похожь на паттерн observer
    который выглядит так:
    (source) -> (data) -> (observer)    <-- данные ТОЛКАЮТСЯ (push) в сторону consumer от source
    опять же данные от одного источника передаются
    на другой - где они обрабатываются
    (указанное направление push-pull и отличает эти два
    паттерна на логическом уровне)

    --  Ситуация создающая проблему:
    --------------------------------
    В игре в инвентаре 4 слота,
    метод "следующий" представляет собою
    итератор,
    но должен после прохождения четвертого слота
    показать первый и так снова по кругу.
    При этом требуется хранить текущий элемент.
    Чтобы при возвращении в инвентарь иметь
    возможность его показать.

    --  Предлагаемое решение:
    -------------------------
    Сделать в дополнение к классу Инвентарь
    класс ИтераторИнвентаря, который как раз и будет
    хранить слот в котором находится следующий
    элемент инвентаря,
    и именно этим ИтераторомИнвентаря получать
    элементы, а не из класса Инвентарь.

    --  Итоговый вариант кода:
    --------------------------
    class Inventory
    {
        int[] slots = new int[]{111,222,333,444};    <- просто структура данных
    }
    class InventoryIterator                          <- может быть несколько итераторв к одному элементу
    {
        Inventory inventory;                         <- итератор знает об итерируемом объекте

        int currentIndex = 0;                        <- индекс внутри итератора (может быть и ссылкою для списков)
        int length = inventory.slots.length();

        InventoryIterator(Inventory inventory)
        {
            this.inventory = inventory;
        }
        int get()                               <- по сути бесконечная итерация
        {
            return inventory.slots[currentIndex];
        }
        void moveNext()
        {
            current = (current + 1)%length;         <- движение индекса по кругу вперед
        }
        void movePrev()                             <- движение индекса по кругу назад
        {
            if((current-1) < 0){current = length-1;}
            else{current -= 1;}
        }
    }
