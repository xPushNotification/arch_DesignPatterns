
    Паттерн 22: ПОСЕТИТЕЛЬ:
---------------------------
    --  Описание паттерна:
    ----------------------
    Представляет собою операцию,
    которая будет выполнена над объектами группы классов.
    Дает возможность определить новую операцию
    без изменения кода классов,
    над которыми эта операция производится.

    Отделение алгоритма оперирующего объекта
    от самого объекта.

    проще говоря
    контроллер хочет вызвать метод в отношении объекта
    базируясь на его типе
    контроллер не зная что это за объект не вызывает его метода
    он делает запрос в сторону объекта
    и объект исходя из своего типа уже сам вызывает метод контроллера
    (контроллер является visitor по отношению к объекту)

    не:
    if(controller.object.type() == TYPE_A) controller.object.invokeMethod();
    а:
    controller.object.visitToInvokeMethod(controller);

    --  Ситуация создающая проблему:
    --------------------------------
    класс КлиентА расширяет Клиент
    класс КлиентБ расширяет Клиент

    нужно послать,
    базируясь на типе КлиентА или КлиентБ
    письмо (письмо будет разным),
    однако не включая метод sendMail
    внутрь этих классов
    (нарушит SingleResponsibility/OpenClosed принципы).

    и избежать в методе sendMail другого класса
    проверку вроде
    if(element instanceof КлиентА) ...
    if(element instanceof КлиентБ) ...

    мы расчитываем, что в любом случае будем
    перебирать клиентов:
    for(Client client : clients)
    {
        ...
    }
    в перечислении мы не можем ввести
    отправкаСообщения(КлиентА ...)
    отправкаСообщения(КлиентБ ...)
    просто потому, что перебирается их
    базовый класс.

    --  Предлагаемое решение:
    -------------------------
    шаг 1. выделить методы sendMail с типом
    из объектов в отдельный класс:
    класс ОтправщикСообщенийТипуКлиента
        отправкаСообщенияКлиентуА
        отправкаСообщенияКлиентуБ
    шаг 2. вставить внутрь КлассА и КлассБ
    метод acceptVisitor с параметром равным типу ОтправкаСообщенийТипуКлиента

    в случае КлассА его код будет
    void accept(ОтправщикСообщенияТипуКлиента visitor)
    {
        visitor.отправкаСообщенияклассуА(this);
    }
    а в случае КлассБ его код будет
    void accept(ОтправщикСообщенияТипуКлиента visitor)
    {
        visitor.отправкаСообщенияКлассуБ(this);
    }
    да, технически в код класса добавиться одна строчка
    внешней функциональности, но САМА функциональность
    и РАСШИРЕНИЕ в класс не попадут.

    --  Итоговый вариант кода:
    --------------------------
    //
    // - базовые операционные типы:
    // ----------------------------
    interface Visitor
    {
        void acceptVisitor(ОтправкаСообщенияТипуКлиента visitor);
    }
    abstract class Client implements Visitor
    {
        String name;
        String address;
    }

    //
    // - требуеемая функциональность:
    // ------------------------------
    class ОтправкаСообщенийТипуКлиента
    {
        void sendMessageToClientTypeA(Client client)
        {
            System.out.println("send message to client A:"+client.name+":"+client.address);
        }
        void sendMessageToClientTypeB(Client client)
        {
            System.out.println("send message to client B:"+client.name+":"+client.address);
        }
    }

    //
    // - в сами классы размещается паттерн Посетитель
    // ----------------------------------------------
    class ClientA extends Client
    {
        // <- изменится тип посетителя = изменится функциональность
        @Override
        void acceptVisitor(ОтправкаСообщенияТипуКлиента visitor)
        {
            visitor.sendMessageToClientTypeA(this);
        }
    }
    class ClientB extends Client
    {
        // <- если будет просто пусто -> под этот тип клиента функциональность не предусмотрена
        @Override
        void acceptVisitor(ОтправкаСообщенияТипуКлиента visitor)
        {
            visitor.sendMessageToClientTypeB(this);
        }
    }

    //
    // - перебираем теперь как тип Client без подстановки instanceof
    // -------------------------------------------------------------
    Client[] clients = new Client[]{
        new ClientA(), new ClientB(), new ClientB(),
    };
    // <- пример станет куда как более показательным
    //    если возникнет второй и третий и так далее
    //    типы посетителей - то есть отдельной функциональности под типы клиентов
    ОтправкаСообщенияТипуКлиента messagingService = new ОтпаравкаСообщенияТипуКлиента();
    for(Client client : clients)
    {
        client.acceptVisitor(messagingService);
    }
