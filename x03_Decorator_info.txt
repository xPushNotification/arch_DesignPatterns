
    Паттерн 03: ДЕКОРАТОР
-------------------------
    --  Описание паттерна:
    ----------------------
    (01) Динамически предоставляет объекту дополнительные возможности.
         Гибкая альтернатива наследования субклассированием для расширения
         функциональности.
    (02) Поведение объекта изменяется в runtime
         путем рекурсивного оборачивания базового объекта (декорирования)
         (ничего не знающего о таком декорировании)
         классами обертками, каждый из которых может
         идти в произвольной последовательности друг к другу,
         и в любом количестве,
         и каждый из которых может базировать (а может и нет) свою работу
         на работе предыдущих.
    (02) Рекурсивное конструирование свойств объекта
         оборачивающими классами
         и создание конфигурации объекта "налету"
    (03) Возможность полностью переопределить поведение объекта
         через обертку его так называемыми "reset" декораторами
    (04) Паттерн НЕ позволяет оценить изнутри объекта сколько декораторов
         к нему применено ПОСЛЕ применения текущего,
         таким образом не всегда хорош для конфигурирования.

    --  Ситуация создающая проблему:
    --------------------------------
    Проблему создает так называемый "class explosion"
    сутью которого является сценарий.

    Есть кафе продающее кофе,
    в нем аппарат по выдече запрограммирован на выдачу кофе
    цена которого указана в классе Brew и выдаваемая методом
    "cost()"
    попытка запрограммировать каждый из видов кофе
    как то
        кофе
        кофе с сахаром
        кофе с молоком
        кофе с сахаром и с молоком
    и так далее
    производит огромное количество классов
    абсолютно не отличающихся друг от друга.

    При этом от поведения ИмяКласса extends Brew
    мы отказаться не можем (то есть изменения в класс Brew не вносимы)

    --  Предлагаемое решение:
    -------------------------
    Создать альтернативную ветку наследования от базового класса
    Brew в виде свойств декораторов, как то
    SugarDecorator, MilkDecorator, CaramelDecorator,
    и подмешивать их к базовому классу Coffee
    следующим образом:

    Brew myCoffee = new MilkDecorator(new SugarDecorator(new CaramelDecorator(new Coffee())))
    - или -
    Brew myCoffee = new Coffee();
    myCoffee = new CaramelDecorator(myCoffee);
    myCoffee = new SugarDecorator(myCoffee);
    myCoffee = new MilkDecorator(myCoffee);

    храня во всех подмешиваемых классах кроме Coffee
    ссылку на оригинал базового класса,
    и переопределяя метод цена следующим образом

    Brew baseClass;
    Caramel(brew baseClass) {this.baseClass = baseClass;}
    int cost()
    {
        baseClass.cost() + this.cost
    }

    как итог, базовым классом для всех объектов будет Brew
    как и для Coffee - объект Coffee будет базовым объектом
    сохраниться метод "cost()" и он итерационно/рекурсивно сможет
    прогрессировать до какого угодно уровня.

    --  Итоговый вариант кода в судо (тут даже и не судо):
    ------------------------------------------------------
    (01) Ветка наследования с оригинальными классами:
    ---
    abstract class Brew
    {
        int getCost(){return 0;}
        String getName(){return "Unnamed Brewery";}
    }

    class Coffee extends Brew
    {
        String name = "Coffee";
        int cost = 1;
        int getCost(){return cost;}
        String getName(){return name;}
    }

    (02) Ветка гибкого наследования с декораторами:
    ---
    abstract class BrewDecorator extends Brew
    {
        Brew baseObject;
        String name;
        int cost;
        int getCost(){ return baseObject.getCost() + cost; }
        String getName()
        {
            if(baseObject instanceof BrewDecorator)
                return baseObject.getName() + " and " + name;

            return baseObject.getName() + " with " + name;
        }
    }

    class SugarDecorator extends BrewDecorator
    {
        SugarDecorator(Brew baseObject)
        {
            super.name = "Sugar";
            super.cost = 3;
            super.baseObject = baseObject;
        }
    }