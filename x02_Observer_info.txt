
    Паттерн 02: OBSERVER
------------------------
    --  Описание паттерна:
    ----------------------
        Один к многим связь между объектами
        при том что когда один объект изменяет состояние
        все связанные уведомляются об этом
        и делают автоматически апдейт

        Действующие лица в паттерне могут именоваться по разному:
        (паттерн все таки больше передает логику связи - а не подписки,
        но понимать его проще как подписку, поэтому и "подписка")
            ActAsASubscriptionServiceAbility = Observable = Subject
            ActAsASubscriberAbility = Observer = Subscriber = Reader

        Если данные управления паттерном хранятся в базе данных
        это так и передается связь одного к многим буквально

        Нужно понимать, что этот паттерн, как и любой другой паттерн
        передает фактически нерабочий упрощенный сценарий,
        и понятно что в итоге, для использования этого паттерна потребуется:
        (здесь ничего этого нет, поэтому описание паттерна на этом уровне
        это описание концепции с минимумом деталей и нерабочей конецепции)
            1. Менеджер сообщений (в том числе способный выстроиться в цепь роутеров)
            2. Возможность передавать сообщение в режиме сетевого подключения
            3. Рассматривать сценарии многих сервисов и многих типов сообщений
            4. Возможность отложенной отработки извещений одним из "многих" при получении
            5. Возможность обработки сообщений с ключами идентификации и сессиями
            6. Возможность отправлять и принимать данные не поштучно, а наборами
            7. Возможность получить данные сразу при подписке
            8. Возможность получать данные не с подписочного сервиса, а откуда то иначе
        Нужно понимать - что по сути итоговая полная реализация механизма
        действует больше как "мессенджер" внутри програмный между объектами, нежели
        чем как вызовы методов и функций друг друга.

    --  Ситуация создающая проблему:
    --------------------------------
        СтанцияПогоды получает данные с датчиков и аккумулирует их у себя
        данные получаются не регулярно, и с разными интервалами от разных датчиков
        (температура, силаВетра, влажность и тд и тп.)

        Телефон и СмартТелевизор хотят получать данные о погоде,
        они опрашивают СтанциюПогоды раз за разом,
        при этом даже тогда когда СтанцияПогоды обновления не получила, и
        данные опрашиваемые приходят теже самые,

        в итоге СтанцияПогоды обновляющая данные раз в день,
        получает запрос на эти данные от одного и того же Телефона или СмартФона
        10 раз в минуту, засыпаясь запросами.

        При этом есть как набор СтанцийПогоды,
        так и набор Телефонов, СмартТелевизоров,
        и в целом они все живут
        отдельными друг от друга жизнями, как у СтанцииПогоды нет понимания
        о количестве объектов кто у неё запрашивать чтото будет,
        в каком объеме (может быть только погоду, может быть и погоду и влажность и тп.)
        так и у Телефонов, СмартТелевизоров, нет понимания - что им и когда может
        понадобиться (что пользователь будет смотреть).

    --  Предлагаемое решение:
    -------------------------
        (01) ПодписочныйСервис (Observable,Subject)
             держит список Подписчиков (Observer,Subscriber,Reader) извещая
             их о необходимости приходить и забирать данные
             Подписываться(Регистрироваться), отписываться(Анрегистрироваться) или нет,
             забирать данные(POLL) или нет,
             с каким интервалом их забирать,
             дело Подписчика, не ПодписочногоСервиса
             --
             ПодписочныйСервис гарантирует лишь извещение Подписчиков по СпискуПодписок
             ПодписочныйСервис НИЧЕГО не знает о Подписчиках, за исключением
             того что они имеют метод (подписаны на события типа у менеджера событий)

             updateMeAsASubscriber()

        (02) Представляет замену POLL(опрос) архитектуры на PUSH-POLL архитектуру
             было:
                Куча Пользователей делают POLL запросы в сторону Сервиса
                на вытягивание данных, даже если они не изменились
             стало:
                ПодписочныйСервис создает PUSH запрос
                в сторону кучи Пользователей
                с тем, что данные изменились,
                после чего Пользователи делают POLL обновленных данных
             осталось:
                POLL запрос при подключении(новой подписке) Пользователя
                к ПодписочномуСервису
        (03) ПодписочныйСервис может делать полный PUSH данных в сторону
             Подпичиков, в этом случае паттерн будет выглядеть не как:
                 (подписка)             POLL (данные)
                 (подписочныйСервис)    PUSH (извещение)
                 (подисчик)             POLL (данные)
             - а -
                 (подписка)             POLL (данные)
                 (подписочныйСервис)    PUSH (извещение + данные)

         (04) В этом упрощенном сценарии подразумевается, что есть
              одна точка приема данных, данных "в принципе",
              а извещение - это "в принципе" извещение
              (отмечаем - как приведение паттерна в рабочий, РЕЗКО будет усложнять код)

    --  Итоговый вариант кода в судо:
    ---------------------------------
        ИнтерфейсИметьВозможностьБытьСервисомПодписок
            addSubscriber( ИнтерфейсИметьВозможностьБытьПодписчиком объектПодписчик )
            removeSubscriber( ИнтерфейсИметьВозможностьБытьПодписчиком объектПодписчик )
            notifySubscribers()
            getDataBySubscriber()

        ИнтерфейсИметьВозможностьБытьПодписчиком
            updateMeAsASubscriber()

        СервисПодписок implements ИнтерфейсИметьВозможностьБытьСервисомПодписок
            ArrayList<ИнтерфейсИметьВозможностьБытьПодписчиком> подписчики

            addSubscriber( ИнтерфейсИметьВозможностьБытьПодписчиком новыйПодписчик )
            removeSubscriber( ИнтерфейсИметьВозможностьБытьПодписчиком имеющийсяПодписчик )
            notifySubscribers()
            getDataBySubscriber()

        Подписчик implements ИнтерфейсИметьВозможностьБытьПодписчиком
            ИнтерфейсИметьВозможностьБытьСервисомПодписок объектОтправкиСообщения
            Подписчик(ИнтерфейсИметьВозможностьБытьСервисомПодписок объектОтправкиСообщения)
            {
                this.объектОтправкиСообщения = объектОтправкиСообщения
            }
            updateMeAsASubscriber()
