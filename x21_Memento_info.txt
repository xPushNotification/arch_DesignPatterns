
    Паттерн 21: МЕМЕНТО-ХРАНИТЕЛЬ:
----------------------------------
    --  Описание паттерна:
    ----------------------
    Не нарушая инкапсуляцию,
    определяет и сохроняет внутреннее состояние объекта
    и позволяет позже
    восстановить объект в таком состоянии.

    Чем не сериализация?

    Паттерн подразумевает, что внутри объекта
    находится:
    (-1-) Объект (Memento) представляющий собою
          результаты сохранения (сериализация?)
          и подразумевающийся к использованию
          за пределами сохраняемого объекта
    (-2-) Два метода,
          управляющие процессом сохранения и загрузки
          элемента.
          Memento xx.takeSnapshot()
          xx.restore(Memento from)

    --  Ситуация создающая проблему:
    --------------------------------
    Текстовый редактор с областью редактирования
    большинство переменных в области редактирования
    внутренние, то есть к ним невозможно получить
    доступ - то есть и невозможно выходит сделать
    снапшот.

    --  Предлагаемое решение:
    -------------------------
    Внести внутрь класса текстового редактора
    внутренний класс представление сохраняемого объекта
    внести два метода сохранения и восстановления

    В клиенте создать очередь таких объектов
    сохранения и восстановления
    добавить метод .undo(очередь последний добавленый элемент)

    --  Итоговый вариант кода:
    --------------------------
    //
    // объект для сохранения и восстановления:
    class TextArea
    {
        String text;

        // <- собственно паттерн:
        public static class Memento
        {
            String savedText;       <- можно сделать и набором из snapshots
            Memento(String textToSave){savedText = textToSave;}
        }
        Memento takeSnapshot(){return new Memento(text);}
        void restore(Memento memento){text = memento.savedText;}
    }

    //
    // клиент:
    class Editor
    {
        Deque<Memento> history = new LinkedList<>();        <- очередь состояний
        TextArea ta = new TextArea();

        void undo()
        {
            ta.restore(history.pop());
        }
    }