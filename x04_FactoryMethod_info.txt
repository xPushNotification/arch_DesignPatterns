
    Паттерн 04: ФАБРИЧНЫЙ_МЕТОД
-------------------------------
    --  Описание паттерна:
    ----------------------
    (01) Определяет интерфейс для создания объекта,
         но позволяет подклассам решать какой класс инстанцировать.
         Позволяет делегировать создание объекта подклассам.
    (02) Вместо создания обьектов через new ClassName(конфигурация, конфигурация)
         они создаются в классе FactoryXXX где XXX имя фабрики
         методом .create() параметрами выступают перечесления с
         enum в порядке ЧТО_ДЕЛАТЬ(тип/набор типов) и КАК_ДЕЛАТЬ(конфигурация)
         может быть отдельно первое, отдельно второе, или оба вместе
         в зависимости от фабрики.
    (03) Фабрика это контроль за выпуском объектов, через ответ на три вопроса:
         Что создавать - наборы классов в фабрике и их подтипы
         Как создавать - наборы конфигураций к созданию классов
         Где создавать - инстанс фабрики, который может быть заменен

    Обычно фабрика оформляется как:
    var newObject = ObjectClassName.of(... параметры создания)

    --  Ситуация создающая проблему:
    --------------------------------
    Существует объект Park
    в него помещаются классы типа Animal
    с подклассами имеющимися сейчас: Cat,Dog,Duck
    в разном количестве и с разными конфигурациями, окрасками, подтипами и тд и тп.

    то есть может быть Cat("black") может быть RubberDuck() и Duck(),
    а может быть Dog(name:Rover", owner:"John",type:"big")

    и все они выпускаются в одном месте при создании парка.
    хочется оттестировать разные сценарии не влезая при этом в сами классы.

    --  Предлагаемое решение:
    -------------------------
    Если речь идет о сценарии когда подразумевается выпуск по конфигурациям
    вместо прямого создания объектов, создается имя конфигуарации в виде enum
    после чего эта конфигурация выпуска помещается в фабрику
    которая уже выпуск объектов и совершает.

    Очевидно, что указание сценария WEAK_CREATURE это может быть и здоровье 10% и 20%
    и разный тип создания, и такое объединение внутри фабрики удобнее чем
    в самих классах (более того сама фабрика может поменяться, в процессе исполнения,
    таким образом мы получим другую трактовку всех конфигураций выпуска)

    --  Итоговый вариант кода:
    --------------------------

    //
    // -- Что создавать:
    //
    abstract class Animal{String type; String getType(){return type;}}
    class Cat {String type = "Cat";  String getType(){return type;}}
    class Dog {String type = "Dog";  String getType(){return type;}}
    class Duck{String type = "Duck"; String getType(){return type;}}

    //
    // -- Как создавать:
    //
    enum AnimalScenario
    {
        MANY_CATS,
        MANY_DOGS,
    }

    //
    // -- Где создавать:
    //
    class FactoryOfAnimals
    {
        Animal create(AnimalScenario scenario)
    }

    class Park
    {
        ArrayList<Animal> animals
        Park(AnimalScenario scenario, int numberOfAnimals)
    }