
    Паттерн 08: АДАПТЕР
-----------------------
    --  Описание паттерна:
    ----------------------
    (00) Имеется класс не имеющий нужного нам интерфейса
         мы создаем класс адаптер с нужным интерфейсом
         который в конструкторе получает класс без такого интерфейса
         и внутренними методами реализует поддержку нужного нам интерфейса

         было:
         -----
            class Some

         нужно (хочется, но не можется):
         -------------------------------
            class Some implements SomeInterface

         стало:
         ------
            class AdapterSome implements SomeInterface
                Some wrappedObject

         теперь используем:
         ------------------
                        <- нужн.интерфейс       <-адаптер       <- от объекта
            SomeInterface neededInterface = new AdapterSome(new Some());
            -- по сути вместо --
            SomeInterface neededInterface = new Some();

         очевидно:
         ---------
             1. можно сделать поддержку интерфейса и иначе (например через extends)
             2. обычный враппер объекта - не является паттерном интерфейса - хотя делает 99% от него
                и в стандартной библиотеке именно враппер обычно и используется, а не интерфейс
             3. суть именно в том, чтобы получить SomeInterface neededInterface от new Some()
                для этого и нужен адаптер.

    (01) Конвертирует интерфейс класса в другой интерфейс,
         ожидаемый клиентом.
         Позволяет классам с разными интерфейсами работать вместе.
    (02) Фактически является индиректным вызовом
         мы вызываем чтото - что вызывает уже чтото с дополнительной
         логикою.
    (03) Паттерн представляет реализацию конструкции:

             WhatWeWantAble adapter = new Adapter(fromWhatWeWant)
             (слева желаемый интерфейс)----------(справа из чего)
             (слева желается что)-----------------------(от чего)

         логика соединения при этом чаще всего Wrapper, однако может и меняться
         суть имено в приведенной конструкции использования.
         (захваченный через обертывание объект называется "adaptee" - то есть "адаптируемый")

         по сути:
         адаптер предоставляет интерфейс адаптирующий поведение "adaptee"
         под такой интерфейс.

         Интерфейс при этом может быть как СУЩЕСТВУЮЩИЙ так и ВНОВЬ_СОЗДАВАЕМЫЙ
         при существующем это будет выглядеть со стороны как "создание на основе":

            Reader reader = new Reader();
            BufferedReader bufferedReader = new BufferedReader(reader);

         например:
             я хочу работать с файлом как со строкою:
                 BeLikeAStringAble adapter = new Adapter(fileHandler)
             я хочу сделать сокет массивом строк:
                 BeLikeStringArrayAble adapter = new Adapter(socketHandler)
             и тд и тп.
         при этом ILikeAString совместим с String, а ILikeStringArray
         совместим с ArrayList<String> на уровне того что является его
         суб-классом, или релизует его интерфейс (опять же может меняться).

    --  Ситуация создающая проблему:
    --------------------------------
    есть объект класса А (уже созданый и с данными и final)
    и объект класса Б (уже созданый и с данными и final)
    никак не связаные друг с другом,

    мы хотим чтобы они были совместимы на уровне интерфейса .getLine
    при этом не добавить этот интерфейс к классам невозможно
    и наследоваться от них также невозможно

    аналогично объекты этим функционалом объеденить в массив примерно также
    невозможно.

    --  Предлагаемое решение:
    -------------------------
    Ввести интерфейс с методом .getLine - GetLineInterface
    ввести объект адаптера (AdapterFromAToGetLineInterface)
    принимающего классА и возвращающего такой интерфейс
    повторить процедуру для классаБ (AdapterFromBToGetLineInterface)

    сам объект классА или классБ будут храниться внутри
    соответственно AdapterFromAToGetLineInterface / AdapterFromBToGetLineInterface
    ----
    (!!!)
    при этом мы не можем адаптировать
    классА напрямую к классБ
    но если классБ имеет интерфейс какой то
    то классА может адаптированым быть к этому интерфейсу
    (но это по сути тоже самое)

    --  Итоговый вариант кода:
    --------------------------
    //
    // -- какие то произвольные классы:
    final class ClassA
        int data                      <- не совместимые данные
    final class ClassB
        String data1; String data2;   <- не совместимые данные

    //
    // -- жеаемый интерфейс:
    interface GetLineInterface
        getLine()

    //
    // -- адаптер из ClassA на GetLineInterface
    class AdapterFromAToGetLine implements GetLineInterface
        ClassA classA
        AdapterFromAToGetLine(ClassA classA) {this.classA = classA}
        --
        String getLine()
        {
            return ""+classA.data;
        }

    //
    // -- адаптер из ClassB на GetLineInterface
    class AdapterFromBToGetLine implements GetLineInterface
        ClassB classB
        AdapterFromBToGetLine(ClassB classB) {this.classB = classB}
        --
        String getLine()
        {
            return ""+classB.data1+""+classB.data2;
        }
