
    Паттерн 10: ПРОКСИ:
-----------------------
    --  Описание паттерна:
    ----------------------
    Предоставляет замену другого объекта
    для контроля доступа к нему.

    Прокси ПОЛНОСТЬЮ скрывает объект, перекрывая все ссылки на него собою
    (то есть нигде в программе оригинальный объект получить не выйдет).
    Места создания объекта заменяются созданием прокси.

    Виды прокси:
    (1) RemoteProxy - прокси вызывает удаленные методы, так как если бы они были бы локальными (оригинально RMI)
    (2) VirtualProxy - прокси старается заменить дорогие вызовы более дешевыми (типичная враппер концепция)
                       логически именно эту концепцию часто и называют Декоратором (CachingDecorator)
    (3) ProtectionProxy - прокси обеспечивает контроль к незащищенными методам обьекта

    Прокси модель появляется обычно на готовом коде (отличается наверное лишь RemoteProxy,
    хотя он не является изначально хорошей архитектурою).
    Ну и по сути прокси это антипаттерн, так как объект прокси:
        1. делает то что делает оригинальный объект
        2. делает еще чтото сверху

    Очень похож внешне на декоратор, однако
    смысл декоратора:
        -- дать дополнительные свойства(характеристики) объекту --
           через декорационные обертки
    смысл же прокси:
        -- перехватить и контролировать доступ --
           через убирание замену доступа к объекту доступом к себе

    В декораторе существует базовый объект который начинает обертываться
    обертками, прокси - может вообще не иметь базового объекта (эмулировать его),
    а просто иметь общий с ним интерфейс.

    Предполагается, что объект хотя бы имеет интерфейс(ы) перед собою
    под который подстраивается прокси (альтернатива потому что будет
    наследоваться от объекта, что не очень хорошо)

    Конструктор прокси равен конструктору объекта.
    Интерфейс прокси равен интерфейсу объекта.

    Как и с врапперами наличие Прокси увеличивает количество объектов в программе
    при этом суть подмены объекта - делает такой рост не здоровым.

    Вместо архитектуры:
    Client -> ServiceForGettingObject -> Object
    -- мы получаем --
    Client -> НеОчевидныйПрокси -> Object

    --  Ситуация создающая проблему:
    --------------------------------
    Сценарий на RemoteProxy:
    ----
        Систему создавали на одном сервере, она работала
        с одним объектом снятия статистики.

        Теперь систему решили масштабировать
        два объекта снятия статистики находится локально,
        а добавляемый находится на удаленной машине.

        Все рутины обработки итогов статистики уже написаны.

    Сценарий на VirtualProxy:
    ----
        В системе существует объект доступы к которому идут постоянным потоком,
        их нужно тротлить во первых и кешировать во вторых,
        в некоторых местах,
        а в других не нужно.

        Логика объекта уже выписана и он повсеместно используется.

    Сценарий на ProtectionProxy:
    ----
        Система разрабатывалась без системы защиты
        после чего система защиты появилась
        однако везде где только можно стоят не безопасные объекты
        и без логирования и без контроля доступа.

    --  Предлагаемое решение:
    -------------------------
        Вводим интерфейс на базу объекта который будет перехватывать прокси
        Вводим прокси обьект реализующий требуемый функционал
        Там где надо в коде заменяем обычный объект прокси объектом

    --  Итоговый вариант кода:
    --------------------------
    //
    // - базовая конструкция
    //
    interface FunctionalityAbility
        doFunctionality()

    class OriginalFunctionality implements FunctionalAbility
        doFunctionality()
        OriginalFunctionality(String dataForTheConstructor)

    //
    // - контроль доступа в виде прокси (и дополнения)
    //
    class AuthTesting
        static boolean authIsOk()
        {
            return true;
        }
    class OriginalFunctionalityProxy implements FunctionalityAbility
        OriginalFunctionality originalObject = null;                        <- оригинальный объект
        OriginalFunctionalityProxy(String dataForTheConstructor)            <- аналогичный конструктор
        {
            originalObject = new OriginalFunctionality(dataForTheConstructor);
        }
        doFunctionality()                                                   <- модифицированное поведение
        {
            <- дополнительные модификаторы ДОСТУПА
            if(AuthTesting.authIsOk() != true) throw Error("Auth failed");

            <- ориганильный объект
            originalObject.doFunctionality();
        }

    //
    // - контроллер
    //
    class Runner
    {
        public static void xfMVCControllerMain(String[] args)
        {
            //
            // было:
            FunctionalityAbility object = new OriginalFunctionality("initial data");

            //
            // стало <- технически это не враппер:
            object = OriginalFunctionality("initial data");
        }
    }