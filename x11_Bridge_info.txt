
    Паттерн 11: BRIDGE:
-----------------------
    --  Описание паттерна:
    ----------------------
    Разделяет абстракцию и реализацию
    так чтобы они могли изменяться независимо.
    --
    Разделение нескольких осей признаков на две иерархии
    и комбинирование их через "мост"
    по сути реализуя "композицию" вместо "наследования"

    первую иерархию представляя абстрактным классом
    а вторую объектом захваченым через интерфейс внутри этого класса

    вообще по сути если тему дальше развивать то
    все классы захватываемые друг в друге должны бы быть
    абстрактными с количеством мостов внутри друг друга
    выдающими пересечения,
    но здесь пример более простой - всего на две иерархии.
    --
    технически наиболее простая реализация этого паттерна
    это как раз DependencyInjection
    когда по одной оси признаков только одна абстракция (Стратегия),
    по другой же оси их несколько.

    но, в реальности, таких соединений можно
    выстроить относительно друг друга сколько угодно.

    ну и соединение может идти как со стороны одной абстракции вниз
    так и с любой стороны в любую сторону.
    --
    Связь с любой стороны на любую сторону (это все ОДНА точка):
    PointX                  <- может плодить наследников вроде PointXFloat, PointXComplex
        int coordinate
        PointY pointY
        PointZ pointZ
    PointY                  <- аналогично может плодить наследвников вроде PointYFloat, PointYComplex
        int coordinate
        PointX pointX
        PointZ pointZ
    PointZ                  <- и здесь наследование также - то есть наследование идет по осям..
        int coordinate
        PointX pointX       <- ..связанных мостами друг с другом..
        PointY pointY       <- .. так как это все логически одна точка

    var point = new PointX(10, new PointY(10), new PointZ(10))  -- это
    var point = new PointZ(10, new PointX(10), new PointZ(10))  -- тоже самое что и это

    или с одной стороны только вперед:
    PointX
        int coordinate
        PointY pointY       <- это и называется логически "мост"
    PointY
        int coordinate
    var point = new PintX(10, new PointY(10))   -- в другом порядке не создашь

    Упрощенный вариант, это вторую часть представить в виде только интерфейса:
    (ну и гипотетически можно первую часть представить в виде также наследования)
    PointX                          <- первая размерность это класс
        int coordinateX
        void actAsPointX()
        PointInterface point        <- это и есть мост от первой размерности ко второй (какой не понятно)
    PointInterface                  <- вторая размерность это интерфейс
        void actAsPoint()
    PointY implements PointInterface
        int coordinateY
        void actAsPoint()
    PointZ implements PointInterface
        int coordinateZ
        void actAsPoint()
    var point = new PointX(10, new PointZ(10))  -- XZ
    var point = new PointX(10, new PointY(10))  -- XY

    --  Ситуация создающая проблему:
    --------------------------------
    Компания выпускает два вида пицц
        Американская
        Итальянская
    они представлены классами-рецептами

    после этого решает расширить ассортимент
    появляются Веганские
    то есть получаются в итоге:
        АмериканскаяОбычная
        АмериканскаяВеганская
        ИтальянскаяОбычная
        ИтальянскаяВеганская
    система как видим развивается в геометрической прогрессии,
    эту проблему уже решали в виде декораторов,
    но у нас обе оси вроде бы как идентичные и базы как таковой нет.

    --  Предлагаемое решение:
    -------------------------
    Предлагается две оси представлять отдельно,
        ТипИтальянскаяИлиАмериканская
        - вид-
        ВидОбычнаяИлиВеганская
    связав их наличием композиционной ссылки на ВИД внутри ТИПА
    тип при этом представлять АБСТРАКТНЫМ КЛАССОМ, а вид ИНТЕРФЕЙСОМ
    делая DependencyInjection.

    Так мы логически представим единицу пиццы как ТИП, так как
    в нем как раз композиция и будет находиться.

    Это позволит и линейку типов ростить сколько угодно вверх,
    и линейку от видов.

    В нашем примере ТИП мы назовем ТипКухни, а ВИД назовем ВидПиццы

    --  Итоговый вариант кода:
    --------------------------
    //
    // -- линейка видов:
    //
    interface ВидПиццы                          <- обобщение по виду
        class ВеганскийВид extends ВидПиццы       <- линейка по видам
        class ОбычныйВид extends ВидПиццы         <- линейка по видам
    //-----------------------
    //
    // -- линейка типов:
    //
    abstract class Пицца                       <- обобщение по типу (корректно было бы ТипПиццы)
        ВидПиццы мостНаВидПиццы                 <- собственно "мост"
        ТипПиццы(ВидПиццы какойВидПиццы)
        {
            мостНаВидПиццы = какойВидПиццы
        }
    class ТипПиццыАмериканская extends Пицца           <- линейка по видам
        ТипПиццыАмериканская(ВидПиццы какойВидПиццы)
        {
            super.ТипПиццы(какойВидПиццы)
        }
    class ТипПиццыИтальянская extends Пицца           <- линейка по видам
        ТипПиццыИтальянская(ВидПиццы какойВидПиццы)
        {
            super.ТипПиццы(какойВидПиццы)
        }
    //-----------------------
    //
    // - клиент:
    //
    class Restaurant
    {
        public static void xfMVCControllerMain(String[] args)
        {
            Пицца pizza01 = ТипПиццыАмериканская(new ВеганскийВид())
            Пицца pizza02 = ТипПиццыВеганская(new ОбычныйВид())
        }
    }
